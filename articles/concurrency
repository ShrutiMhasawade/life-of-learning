Concurrency*
============

"Do not communicate by sharing memory, instead, share memory by communicating" is the motto of Golang concurrency. It is understandable once you understand goroutines and channels and truly understand concurrency. But that comes later. For now, an analogy! There are a bunch of gophers using a single chainsaw to cut trees. Now there is a problem. There are multiple gophers and only 1 chainsaw. :( The motto means that the gophers should NOT do the thing where they make some checkout list or have checkout times or have some special spot that the chainsaw resides and the gophers just wait in a line until the chainsaw is back in the spot for the next gopher to use it. Why? Because it's hard! Some gopher has to maintain that list, some gopher has to make sure the checkout times are not overlapping, some gopher has to make sure that the line is organized and that all the gophers aren't just stuck waiting for some annoying gopher who is hogging the chainsaw.

Wouldn't it be easier if a gopher was originally given the chainsaw and then whenever someone needed it, they could just ask whichever gopher had the chainsaw? YES! This way, things are spread out! This way, there is less complexity.

And that's what the motto means. 

Sharing is caring.  

Goroutines:

Definition - a function that has the word "go" in front of it. For example: 
	go myfunc()

Yes, I'm screwing with you. But not really.
What happens when you put the word "go" in front of a function is that golang creates an internal OS system thread**. The thread can do work at the same time as your main thread, thus concurrency. The thread is in the same address space as your original thread, thus you have access to the same memory that your original thread did. The thread is super lightweight meaning its not super slow to create a bunch of these threads. The threads grow/lessen dynamically meaning that as you shove more work on the thread it grows and if you reduce work, it gets smaller. Managing a thread is hard. Golang makes it so that we don't have to worry about it. We can legit just write go myfunc() and know that myfunc() is just going to be done in the background. YAY! 

Okay, thats all the prose I can handle for now. Let's get down to it.

Example:
	go list.Sort() // run list.Sort concurrently. don't wait for it



Channels:

A channel is a DATA STRUCTURE. It goes lots of cool things, yes, however, it is good to think of it primarily as a data structure in order to grasp its full potential.  




*This is a very intro article on goroutines/channels. It is intro in the sense that the material is intro material, as is my understanding. I will certainly update the article if I figure out something I wrote is wrong.
**the goroutines are actually multiplexed onto the os system threads
