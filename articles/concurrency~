Concurrency*
============

"Do not communicate by sharing memory, instead, share memory by communicating" is the motto of Golang concurrency. It is understandable once you understand goroutines and channels and truly understand concurrency. But that comes later. For now, an analogy! There are a bunch of gophers using a single chainsaw to cut trees. Now there is a problem. There are multiple gophers and only 1 chainsaw. :( The motto means that the gophers should NOT do the thing where they make some checkout list or have checkout times or have some special spot that the chainsaw resides and the gophers just wait in a line until the chainsaw is back in the spot for the next gopher to use it. Why? Because it's hard! Some gopher has to maintain that list, some gopher has to make sure the checkout times are not overlapping, some gopher has to make sure that the line is organized and that all the gophers aren't just stuck waiting for some annoying gopher who is hogging the chainsaw.

Wouldn't it be easier if a gopher was originally given the chainsaw and then whenever someone needed it, they could just ask whichever gopher had the chainsaw? YES! This way, things are spread out! This way, there is less complexity.

And that's what the motto means. 

Sharing is caring.  

Goroutines:

Definition - a function that has the word "go" in front of it. For example: 
	go myfunc()

Yes, I'm screwing with you. But not really.
What happens when you put the word "go" in front of a function is that golang creates an internal OS system thread**. The thread can do work at the same time as your main thread, thus concurrency. The thread is in the same address space as your original thread, thus you have access to the same memory that your original thread did. The thread is super lightweight meaning its not super slow to create a bunch of these threads. The threads grow/lessen dynamically meaning that as you shove more work on the thread it grows and if you reduce work, it gets smaller. Managing a thread is hard. Golang makes it so that we don't have to worry about it. We can legit just write go myfunc() and know that myfunc() is just going to be done in the background. YAY! 

Okay, thats all the prose I can handle for now. Let's get down to it.

Example:
	go list.Sort() // run list.Sort concurrently. don't wait for it

You can use goroutines with closures, allowing you to run a program in the main thread and have your variables all set up and defined there, BUT then even if the function has returned, the variables will exist in the goroutine.

Example:
	func myfunc(message String){
		//anonymous function
		//this anonymous function will run in the background.
		//thus as soon as myfunc is started, it will start this in the backgorund and return.
		//there is no time to sleep and print the message. Normally, youd think that message is nil in the anonymous function because myfunc already returned. But alas, thats the beaty of closures. message will remain in memory while the anonymous function is running.  
		go func(){ 
			time.Sleep(30)
			fmt.Println(message)
		}()
	}
	
	func main(){
		myfunc("hi") //func A will run and immidiently end.
		for {} //infinite loop so that main doesnt end
	}


*This is a very intro article on goroutines/channels. It is intro in the sense that the material is intro material, as is my understanding. I will certainly update the article if I figure out something I wrote is wrong.
**the goroutines are actually multiplexed onto the os system threads
